/**
 * (c) 2019 cepharum GmbH, Berlin, http://cepharum.de
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2019 cepharum GmbH
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @author: cepharum
 */

const UDP = require( "dgram" );


/**
 * Cache singleton instance used to capture all logs.
 *
 * @type {LogServer}
 * @private
 */
let server;

/**
 * Caches socket instance used for transmitting messages as a client.
 *
 * @type {Socket}
 * @private
 */
let client;


/**
 * Implements UDP-based receiver for collecting log messages generated by
 * multiple clients.
 */
class LogServer {
	/**
	 * Fetches singleton server instance.
	 *
	 * @returns {LogServer}
	 */
	static get() {
		if ( !server ) {
			server = new this();
		}

		return server;
	}

	/**
	 * @param {int} bufferSize maximum number of records to keep
	 */
	constructor( bufferSize = null ) {
		const _size = Math.max( parseInt( bufferSize ) || process.env.DEBUG_LOG_BUFFER || 100, 100 );
		let write = 0;

		Object.defineProperties( this, {
			/**
			 * Provides recently received log records.
			 *
			 * @name LogServer#logs
			 * @property {Array<{peer: string, msg: Buffer}>}
			 * @readonly
			 */
			logs: { value: new Array( _size ) },
		} );

		Object.defineProperties( this, {
			/**
			 * Exposes raw socket receiving incoming records.
			 *
			 * @name LogServer#_socket
			 * @property {Socket}
			 * @readonly
			 * @protected
			 */
			_socket: {
				value: UDP.createSocket( "udp4", ( msg, rinfo ) => {
					if ( write === _size ) {
						this.logs.splice( 0, 1 );
						write--;
					}

					this.logs[write++] = {
						peer: `${rinfo.address}:${rinfo.port}`,
						msg
					};
				} ),
			},
		} );

		Object.defineProperties( this, {
			/**
			 * Promises socket ready for receiving messages.
			 *
			 * @name LogServer#socket
			 * @property {Promise<Socket>}
			 * @readonly
			 */
			socket: {
				value: new Promise( ( resolve, reject ) => {
					const socket = this._socket;

					const onError = error => {
						socket.close();
						reject( error );
					};

					socket.once( "error", onError );
					socket.once( "listening", () => {
						socket.off( "error", onError );
						resolve( socket );
					} );

					socket.bind();
				} ),
			},
		} );

		Object.defineProperties( this, {
			/**
			 * Promises address of prepared socket receiving incoming messages.
			 *
			 * @property {Promise<{address: string, family: string, port: int}>}
			 * @readonly
			 */
			address: {
				value: this.socket.then( socket => {
					const { address, family, port } = socket.address();

					return {
						address: address === "0.0.0.0" ? "127.0.0.1" : address,
						family,
						port,
					};
				} )
			},
		} );
	}

	/**
	 * Transmits provided message to log server selected by environment
	 * variables.
	 *
	 * @param {string} message log message to be transmitted
	 * @returns {void}
	 */
	static transmitLog( message ) {
		process.stderr.write( message + "\n" );

		const { DEBUG_LOG_SERVER_NAME, DEBUG_LOG_SERVER_PORT } = process.env;

		if ( DEBUG_LOG_SERVER_NAME && DEBUG_LOG_SERVER_PORT ) {
			if ( !client ) {
				client = UDP.createSocket( "udp4" );
			}

			client.send( Buffer.from( message, "utf8" ), DEBUG_LOG_SERVER_PORT, DEBUG_LOG_SERVER_NAME );
		}
	}
}

module.exports = LogServer;
